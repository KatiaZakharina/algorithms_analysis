from numpy.random import randint

from hashing import Hashing

# 1) Реализовать алгоритмы бинарного и интерполяционного поиска числа x в массиве длины N,
# элементы которого - случайные целые числа в диапазоне от 0 до M.
# Вывести число операций сравнения, выполненных алгоритмом для заданных величин.


# 2) Реализовать алгоритмы построения, обхода и балансировки дерева бинарного поиска.
# На вход алгоритма подается последовательность целых положительных чисел.
# Программа должна строить BST, добавляя узлы в порядке последовательности.
# Реализовать обходы дерева по возрастанию и по убыванию узлов.
# Реализовать алгоритм нахождения k-го минимального ключа в дереве.
# На его основе сбалансировать построенное дерево
# (ротациями вправо и влево (n/2)-ый минимальный элемент помещается в корень и это повторяется рекурсией в дочерних узлах).

# 3) Реализовать хэширование умножением с разрешением коллизий цепочками переполнения,
# линейным зондированием и двойным хэшированием.
# Провести вычислительный эксперимент: подобрать константу для метода умножения,
# сравнить ее с константой Кнута по наибольшей длине цепочек коллизий
# (например, проитерировать константу Кнута, уменьшая или увеличивая с очень малым шагом)

MAX_VALUE = 100
VALUES_SIZE = 11
TABLE_SIZE = 7


def run_hashing():
    values = generate_array(VALUES_SIZE, MAX_VALUE)
    print('Values: ', values)
    hash_table = Hashing(TABLE_SIZE)

    for number in values:
        hash_table.insert(number, True)

    hash_table.print()


def generate_array(size, max_value):
    return randint(0, max_value, size)


def init():
    print('3) Hashing: ')
    run_hashing()


if __name__ == '__main__':
    init()
